import torch
from typing import Union, Optional
import numpy as np

from ._states import QuantumStateVector, DensityMatrix, COMPLEX_DTYPE

def random_state_vector(num_qubits: int, 
                       device: Union[str, torch.device] = 'cpu',
                       dtype: Optional[torch.dtype] = None,
                       normalize: bool = True) -> QuantumStateVector:
    """
    Generates a random quantum state vector for a system of qubits.
    
    The state vector is generated by sampling from a complex normal distribution
    and optionally normalizing it.
    
    Args:
        num_qubits: The number of qubits. Must be a positive integer.
        device: The PyTorch device (e.g., 'cpu', 'cuda') where the tensor
            should be stored. Defaults to 'cpu'.
        dtype: Optional PyTorch dtype for the state vector. If None, uses COMPLEX_DTYPE.
        normalize: If True, normalizes the state vector to have unit norm.
            Defaults to True.
            
    Returns:
        A QuantumStateVector object representing the random state.
        
    Raises:
        ValueError: If num_qubits is not positive.
    """
    if not isinstance(num_qubits, int) or num_qubits <= 0:
        raise ValueError("num_qubits must be a positive integer.")
        
    dim = 2**num_qubits
    _dtype = dtype if dtype is not None else COMPLEX_DTYPE
    
    # Generate random complex numbers from normal distribution
    real_part = torch.randn(dim, dtype=torch.float32, device=device)
    imag_part = torch.randn(dim, dtype=torch.float32, device=device)
    state_vector = real_part + 1j * imag_part
    
    if normalize:
        # Normalize the state vector
        norm = torch.sqrt(torch.sum(torch.abs(state_vector)**2))
        state_vector = state_vector / norm
        
    return QuantumStateVector(num_qubits=num_qubits, 
                            initial_state_tensor=state_vector,
                            device=device)

def random_density_matrix(num_qubits: int,
                         device: Union[str, torch.device] = 'cpu',
                         dtype: Optional[torch.dtype] = None,
                         normalize: bool = True) -> DensityMatrix:
    """
    Generates a random density matrix for a system of qubits.
    
    The density matrix is generated by:
    1. Creating a random complex matrix
    2. Making it Hermitian by adding its conjugate transpose
    3. Making it positive semidefinite by multiplying with its conjugate transpose
    4. Optionally normalizing to have unit trace
    
    Args:
        num_qubits: The number of qubits. Must be a positive integer.
        device: The PyTorch device (e.g., 'cpu', 'cuda') where the tensor
            should be stored. Defaults to 'cpu'.
        dtype: Optional PyTorch dtype for the density matrix. If None, uses COMPLEX_DTYPE.
        normalize: If True, normalizes the density matrix to have unit trace.
            Defaults to True.
            
    Returns:
        A DensityMatrix object representing the random mixed state.
        
    Raises:
        ValueError: If num_qubits is not positive.
    """
    if not isinstance(num_qubits, int) or num_qubits <= 0:
        raise ValueError("num_qubits must be a positive integer.")
        
    dim = 2**num_qubits
    _dtype = dtype if dtype is not None else COMPLEX_DTYPE
    
    # Generate random complex matrix
    real_part = torch.randn((dim, dim), dtype=torch.float32, device=device)
    imag_part = torch.randn((dim, dim), dtype=torch.float32, device=device)
    random_matrix = real_part + 1j * imag_part
    
    # Make it Hermitian and positive semidefinite
    density_matrix = random_matrix @ random_matrix.conj().T
    
    if normalize:
        # Normalize to have unit trace
        trace = torch.trace(density_matrix).real
        density_matrix = density_matrix / trace
        
    return DensityMatrix(num_qubits=num_qubits,
                        initial_density_matrix_tensor=density_matrix,
                        device=device)

def random_pure_state(num_qubits: int,
                     device: Union[str, torch.device] = 'cpu',
                     dtype: Optional[torch.dtype] = None) -> DensityMatrix:
    """
    Generates a random pure state as a density matrix.
    
    This is equivalent to generating a random state vector and converting it
    to a density matrix.
    
    Args:
        num_qubits: The number of qubits. Must be a positive integer.
        device: The PyTorch device (e.g., 'cpu', 'cuda') where the tensor
            should be stored. Defaults to 'cpu'.
        dtype: Optional PyTorch dtype for the state. If None, uses COMPLEX_DTYPE.
            
    Returns:
        A DensityMatrix object representing the random pure state.
        
    Raises:
        ValueError: If num_qubits is not positive.
    """
    state_vector = random_state_vector(num_qubits, device, dtype)
    return state_vector.to_density_matrix() 